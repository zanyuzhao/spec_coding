# 自循环实现（需求分析 → 任务拆分 → 逐项开发与测试）

**前置条件**：仅当用户**已确认**需求说明与设计文档（或已按用户要求修改文档），并明确说「继续开发」「按文档开发」「开始实现」等之后，才执行本流程。若当前 active 仍处于「待用户确认文档」状态（刚产出 spec 未确认），应先提示用户查看并确认文档，再说「继续开发」后再实现。

当用户要求「按某 active spec 实现」「实现当前需求」「从 spec 做到可运行/测试通过」或已确认文档后说「继续开发」时，必须按本流程执行，直到验收通过或明确需要用户决策为止。

## 执行流程

1. **读 spec**  
   读取 `docs/spec/active/` 下指定的 spec 文件（或用户指明的 active 项）。若 spec 同目录下有 `tasks.md`，以其中任务列表为主；否则根据 spec 内容自行拆分任务。

2. **需求分析与任务拆分**  
   - 从 spec 中提炼：接口/端点、数据模型、前后端改动点、边界与错误处理。  
   - 输出**可执行任务列表**（顺序可依依赖关系）：例如「1. 后端：新增 GET /api/xxx 2. 后端：新增 Pydantic 模型 3. 前端：列表页与请求 4. 验收：跑 pytest 与 build」。  
   - 若 spec 中已有「任务拆分」或「验收」段，直接采用并补全遗漏项。

3. **逐项实现**  
   - 按任务列表顺序实现，每完成一类或一项可做一次小步提交（可选）。  
   - 实现时遵守 `docs/spec_process/CHECKLISTS.md` 的「开发清单列表」及本目录下 `fastapi_shield.md`、`frontend_architect.md`、`global_guard.md`。

4. **运行验收**  
   - spec 中若有「验收」段或「验收命令」，按其中命令执行（如 `cd backend && pytest tests/...`、`cd frontend && npm run build`）。  
   - 若 spec 未写验收命令，则根据实现内容自行选择：后端跑 `pytest`（或对应测试）、前端跑 `npm run build`，以及必要的冒烟检查。

5. **自循环直到通过或阻塞**  
   - 若验收命令全部通过 → 视为实现完成，简要回复「实现完成，验收已通过」，并列出已完成的项与验收结果。  
   - 若某命令失败 → 根据报错修改代码，然后**再次执行验收命令**；重复「修改 → 执行验收」直到全部通过，或遇到必须由用户决定的依赖/环境/产品选择时，明确说明阻塞点并询问用户。

6. **不主动归档**  
   本流程只做到「实现完成且验收通过」。归档仅在用户**明确说「归档」「开发完成」**等时，按 `spec_manager.md` 的归档流程执行。

## active spec 建议结构（便于自循环）

为减少反复询问，active spec 建议包含以下结构，便于 Claude 自动拆分与验收：

```markdown
status: proposal | implementation

# 需求简述
（一两句话）

# 任务拆分（可选，有则优先采用）
1. 后端：…
2. 前端：…
3. 验收：…

# 验收
- 后端：`cd backend && pytest path/to/test_xxx.py -v`
- 前端：`cd frontend && npm run build`
（或其它可执行的命令）
```

未写「任务拆分」时，由 Claude 根据 spec 正文与「验收」段自行拆解并执行。

## 用户怎么说会触发本流程

- 「按 docs/spec/active/xxx.md 实现，做到验收通过」  
- 「实现当前 active 里的 [需求名]，拆任务、逐项做、跑测试直到过」  
- 「从 spec 做到可运行 / 测试通过」  
- 「按 [某 active spec] 全流程实现并自测通过」

上述表述均表示：执行「需求分析 → 任务拆分 → 逐项开发与测试 → 运行验收 → 失败则修到过」的自循环，无需用户每步确认（除非遇到阻塞或环境问题）。
